#!/usr/bin/env ruby
# frozen_string_literal: true

# Shoryuken integration test runner
#
# Usage:
#   bin/integrations                    # Run all integration tests
#   bin/integrations fifo               # Run tests with 'fifo' in path
#   bin/integrations rails/rails_72     # Run Rails 7.2 tests
#   bin/integrations batch retry        # Run tests matching 'batch' OR 'retry'
#   bin/integrations -v fifo            # Run with verbose output

require 'fileutils'
require 'timeout'

TIMEOUT = 300 # 5 minutes per scenario
SPEC_DIR = File.expand_path('../spec/integration', __dir__)
ROOT_DIR = File.expand_path('..', __dir__)

class IntegrationRunner
  def initialize(args)
    @verbose = args.delete('-v') || args.delete('--verbose')
    @filters = args.reject { |a| a.start_with?('-') }
  end

  def run
    puts 'Shoryuken Integration Tests'
    puts '=' * 50

    if @filters.any?
      puts "Filter: #{@filters.join(', ')}"
    else
      puts 'Running all integration tests'
    end
    puts ''

    specs = find_specs
    specs = filter_specs(specs) if @filters.any?

    if specs.empty?
      puts '[ERROR] No specs found matching filters'
      exit 1
    end

    puts "Found #{specs.size} spec(s) to run"
    puts ''

    results = run_specs(specs)
    report_results(results)
  end

  private

  def find_specs
    Dir.glob(File.join(SPEC_DIR, '**/*_spec.rb')).map do |path|
      relative_path = path.sub("#{SPEC_DIR}/", '')
      dir = File.dirname(path)
      gemfile = File.exist?(File.join(dir, 'Gemfile')) ? File.join(dir, 'Gemfile') : File.join(ROOT_DIR, 'Gemfile')

      {
        name: relative_path.sub('_spec.rb', '').gsub('/', ' / '),
        path: path,
        relative_path: relative_path,
        directory: dir,
        gemfile: gemfile
      }
    end.sort_by { |s| s[:relative_path] }
  end

  def filter_specs(specs)
    specs.select do |spec|
      @filters.any? { |filter| spec[:relative_path].include?(filter) }
    end
  end

  def run_specs(specs)
    results = []

    specs.each do |spec|
      print "Running #{spec[:name]}... "
      $stdout.flush

      result = run_spec(spec)
      results << result

      if result[:success]
        puts 'PASSED'
      else
        puts '[FAILED]'
        if @verbose && result[:output]
          puts result[:output].lines.map { |l| "  #{l}" }.join
        end
      end
    end

    results
  end

  def run_spec(spec)
    env = {
      'BUNDLE_GEMFILE' => spec[:gemfile],
      'RAILS_ENV' => 'test'
    }

    # Install dependencies if using a local Gemfile
    unless spec[:gemfile] == File.join(ROOT_DIR, 'Gemfile')
      install_result = install_bundle(spec, env)
      return install_result unless install_result[:success]
    end

    # Run the spec
    cmd = ['bundle', 'exec', 'ruby', File.join(ROOT_DIR, 'bin/scenario'), spec[:path]]

    output = []
    start_time = Time.now

    begin
      Timeout.timeout(TIMEOUT) do
        IO.popen(env, cmd, chdir: spec[:directory], err: [:child, :out]) do |io|
          io.each_line do |line|
            output << line
            puts "  #{line}" if @verbose
          end
        end
      end

      {
        spec: spec,
        success: $?.success?,
        exit_code: $?.exitstatus,
        duration: Time.now - start_time,
        output: output.join
      }
    rescue Timeout::Error
      {
        spec: spec,
        success: false,
        exit_code: -1,
        error: 'Timeout',
        duration: Time.now - start_time,
        output: output.join
      }
    end
  end

  def install_bundle(spec, env)
    return { success: true } if @bundle_installed&.include?(spec[:gemfile])

    puts "  Installing dependencies..." if @verbose

    output = []
    IO.popen(env, ['bundle', 'install', '--quiet'], chdir: spec[:directory], err: [:child, :out]) do |io|
      io.each_line { |line| output << line }
    end

    @bundle_installed ||= []
    @bundle_installed << spec[:gemfile] if $?.success?

    {
      spec: spec,
      success: $?.success?,
      output: output.join,
      error: $?.success? ? nil : 'Bundle install failed'
    }
  end

  def report_results(results)
    puts ''
    puts '=' * 50
    puts 'Results'
    puts '=' * 50

    successful = results.count { |r| r[:success] }
    total = results.size
    failed = results.reject { |r| r[:success] }

    if failed.any?
      puts ''
      puts 'FAILED:'
      failed.each do |result|
        error = result[:error] ? " (#{result[:error]})" : ''
        puts "  #{result[:spec][:name]}#{error}"
      end
    end

    puts ''
    puts "#{successful}/#{total} passed"

    exit(failed.empty? ? 0 : 1)
  end
end

if __FILE__ == $0
  IntegrationRunner.new(ARGV.dup).run
end
